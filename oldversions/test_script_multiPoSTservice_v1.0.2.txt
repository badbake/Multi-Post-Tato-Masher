# Define user-customizable parameters

# Define instance configurations
$instances = @{
    "PostService1" = @{
        Arguments = @(
            "--address=http://localhost:9094",
            "--dir=../data1",
            "--operator-address=127.0.0.1:50051",
            "--threads=1",
            "--nonces=128",
            "--randomx-mode=fast"
        )
    }
    "PostService2" = @{
        Arguments = @(
            "--address=http://localhost:9095",
            "--dir=../data2",
            "--operator-address=127.0.0.1:50052",
            "--threads=1",
            "--nonces=128",
            "--randomx-mode=fast"
        )
    }
    "PostService3" = @{
        Arguments = @(
            "--address=http://localhost:9096",
            "--dir=../data3",
            "--operator-address=127.0.0.1:50053",
            "--threads=1",
            "--nonces=128",
            "--randomx-mode=fast"
        )
    }
    # Add more PostServices with names and arguments as needed
}

# Specify the trigger date and time in UTC
$triggerDateTimeUtc = Get-Date -Year 2024 -Month 5 -Day 12 -Hour 20 -Minute 0 -Second 0 -Millisecond 0

# End of user-customizable parameters

# Define a function to run an instance
function RunInstance {
    param (
        [string]$instanceName,
        [string[]]$arguments
    )

    # Define the expected responses for grpcurl
    $idleResponse = '"state": "IDLE"'
    $provingResponse = '"state": "PROVING"'

    # Extract operator port number from operator address
    $operatorAddress = ($arguments -like "--operator-address=*")[0]
    $operatorPort = $operatorAddress.Split(":")[1]

    # Construct grpcurl command for the instance
    $grpcUrlCommand = ".\grpcurl.exe --plaintext -d '{}' localhost:$operatorPort spacemesh.v1.PostInfoService.PostStates"

    # Start the service.exe process with the current set of arguments and name
    $serviceProcess = Start-Process -FilePath ".\service.exe" -ArgumentList $arguments -NoNewWindow -PassThru -Name $instanceName

    # Flag to track whether the instance has entered the "PROVING" state
    $provingStateReached = $false

    do {
        # Use the specific grpcurl.exe command to check the status of service.exe
        $response = & $grpcUrlCommand

        # Check if response indicates service is in the "PROVING" state
        if ($response -like "*$provingResponse*") {
            Write-Host "PostService '$instanceName' is in the PROVING state."
            $provingStateReached = $true
            return  # Exit the loop and continue with the instance
        }

        # Check if response indicates service is in the "IDLE" state
        if ($response -like "*$idleResponse*" -and $provingStateReached -eq $false) {
            Write-Host "PostService '$instanceName' is in the IDLE state."
        }
        elseif ($response -like "*$idleResponse*" -and $provingStateReached -eq $true) {
            Write-Host "PostService '$instanceName' is in the IDLE state. Stopping service."
            # Stop the service.exe process
            Stop-Process -Name $instanceName
            return  # Exit the function
        }

        # Sleep for a short duration before the next attempt (optional)
        Start-Sleep -Seconds 5  # Adjust the duration as needed

    } while ($true)  # Infinite loop
}

# Define a function to run all instances sequentially
function RunAllInstances {
    # Loop through the instances
    foreach ($instanceName in $instances.Keys) {
        $instance = $instances[$instanceName]
        $arguments = $instance.Arguments

        # Call RunInstance function for each instance
        RunInstance -instanceName $instanceName -arguments $arguments
    }

    # Output a message indicating that all instances have completed
    Write-Host "All PostServices have completed."
}

# Define a function to wait for the trigger command
function WaitForTrigger {
    # Calculate the time difference between the current date and time and the trigger date and time
    $timeDifference = New-TimeSpan -Start (Get-Date) -End $triggerDateTimeUtc

    # If the trigger date and time is in the past, adjust it to the next occurrence two weeks from now
    if ($timeDifference -lt [TimeSpan]::Zero) {
        $timeDifference = $timeDifference.Add([TimeSpan]::FromDays(14))
    }

    # Wait for the calculated time difference
    Start-Sleep -Seconds $timeDifference.TotalSeconds

    # Trigger the script to run all instances
    while ($true) {
        RunAllInstances
        # Wait for two weeks before running the instances again
        Start-Sleep -Seconds (2 * 7 * 24 * 60 * 60)  # 2 weeks
    }
}

# Trigger the script to wait for the trigger command
WaitForTrigger
